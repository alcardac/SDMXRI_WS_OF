// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.2011051901     
// 5/10/2012 7:21 μμ    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (c) 2012 Metadata Technology Ltd.
/// All rights reserved. This program and the accompanying materials
/// are made available under the terms of the GNU Public License v3.0
/// which accompanies this distribution, and is available at
/// http://www.gnu.org/licenses/gpl.html
/// This file is part of the SDMX Component Library.
/// The SDMX Component Library is free software: you can redistribute it and/or modify
/// it under the terms of the GNU General Public License as published by
/// the Free Software Foundation, either version 3 of the License, or
/// (at your option) any later version.
/// The SDMX Component Library is distributed in the hope that it will be useful,
/// but WITHOUT ANY WARRANTY; without even the implied warranty of
/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/// GNU General Public License for more details.
/// You should have received a copy of the GNU General Public License
/// along with The SDMX Component Library If not, see <http://www.gnu.org/licenses/>.
/// Contributors:
/// Metadata Technology - initial API and implementation
/// </summary>
///
namespace Org.Sdmxsource.Sdmx.SdmxObjects.Model.BaseObjects.Datastructure {
	
	using Org.Sdmxsource.Sdmx.Api.Constants;
	using Org.Sdmxsource.Sdmx.Api.Model.Objects.Datastructure;
	using Org.Sdmxsource.Sdmx.Api.Model.BaseObjects.Base;
	using Org.Sdmxsource.Sdmx.Api.Model.BaseObjects.Codelist;
	using Org.Sdmxsource.Sdmx.Api.Model.BaseObjects.Conceptscheme;
	using Org.Sdmxsource.Sdmx.Api.Model.BaseObjects.Datastructure;
	using Org.Sdmxsource.Sdmx.SdmxObjects.Model.BaseObjects.Base;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	[Serializable]
	public class DataStructureObjectBaseCore : MaintainableObjectBaseCore
		, IDataStructureObjectBase {
		private const long serialVersionUID = 1L;
	
		private readonly IList<IDimensionObjectBase> _dimensions;
		private readonly IList<IAttributeObjectBase> _attributes;
		private readonly IPrimaryMeasureObjectBase _primaryMeasure;
		private readonly IList<IGroupObjectBase> _groups;
		private readonly IDictionary<String, IDimensionObjectBase> conceptDimensionMap;
		private readonly IDictionary<String, IComponentObjectBase> _conceptComponentMap;
		private readonly IDictionary<String, ICodelistObjectBase> _conceptCodelistMap;
		private readonly ISet<ICodelistObjectBase> _referencedCodelists;
	
		private IDataStructureObject keyFamily;
	
		public DataStructureObjectBaseCore(IDataStructureObject dataStructure,
				IList<IDimensionObjectBase> dimensions,
				IList<IAttributeObjectBase> attributes,
				IPrimaryMeasureObjectBase primaryMeasure) : base(dataStructure) {
			this._groups = new List<IGroupObjectBase>();
			this._conceptComponentMap = new Dictionary<String, IComponentObjectBase>();
			this._conceptCodelistMap = new Dictionary<String, ICodelistObjectBase>();
			this._referencedCodelists = new HashSet<ICodelistObjectBase>();
			this.keyFamily = dataStructure;
			this._dimensions = dimensions;
			this._attributes = attributes;
			this._primaryMeasure = primaryMeasure;
	
			//Create Mapping of Concept Id To Dimension that refers to that concept
			conceptDimensionMap = new Dictionary<String, IDimensionObjectBase>();
	
			/* foreach */
			foreach (IDimensionObjectBase currentDimension  in  dimensions) {
				conceptDimensionMap.Add(currentDimension.Id, currentDimension);
				_conceptComponentMap.Add(currentDimension.Id , currentDimension);
				if (currentDimension.GetCodelist(true) != null) {
					_conceptCodelistMap.Add(currentDimension.Id, currentDimension.GetCodelist(true));
					_referencedCodelists.Add(currentDimension.GetCodelist(true));
				}
			}
			if (attributes != null) {
				/* foreach */
				foreach (IAttributeObjectBase attributeObjectBase  in  attributes) {
					_conceptComponentMap.Add(attributeObjectBase.Id , attributeObjectBase);
					if (attributeObjectBase.GetCodelist(true) != null) {
						_conceptCodelistMap.Add(attributeObjectBase.Id, attributeObjectBase.GetCodelist(true));
						_referencedCodelists.Add(attributeObjectBase.GetCodelist(true));
					}
				}
			}
			if (primaryMeasure != null) {
				_conceptComponentMap.Add(primaryMeasure.Id, primaryMeasure);
				if (primaryMeasure.GetCodelist(true) != null) {
					_conceptCodelistMap.Add(primaryMeasure.Id, primaryMeasure.GetCodelist(true));
					_referencedCodelists.Add(primaryMeasure.GetCodelist(true));
				}
			}
			/* foreach */
			foreach (IGroup currentGroup  in  dataStructure.Groups) {
				_groups.Add(new GroupObjectBaseCore(currentGroup, this));
			}
		}
	
		
		public virtual IDataStructureObject IDataStructureObject {
		  get {
				return keyFamily;
			}
		}
		
	
		
		public virtual ISet<ICodelistObjectBase> ReferencedCodelists {
		  get {
				return new HashSet<ICodelistObjectBase>(_referencedCodelists);
			}
		}
		
	
		
		public virtual ISet<IComponentObjectBase> Components {
		  get {
				return new HashSet<IComponentObjectBase>(_conceptComponentMap.Values);
			}
		}
		
	
		
		public virtual ISet<IConceptObjectBase> ReferencedConcepts {
		  get {
				ISet<IConceptObjectBase> returnConcepts = new HashSet<IConceptObjectBase>();
				/* foreach */
				foreach (IComponentObjectBase currentComponent  in  _conceptComponentMap.Values) {
					returnConcepts.Add(currentComponent.Concept);
				}
				return returnConcepts;
			}
		}
		
	
		public virtual ICodelistObjectBase GetCodelistByComponentId(String conceptId) {
			return _conceptCodelistMap[conceptId];
		}
	
		public virtual IComponentObjectBase GetComponentById(String conceptId) {
			return _conceptComponentMap[conceptId];
		}
	
		
		public virtual IDimensionObjectBase TimeDimension {
		  get {
				/* foreach */
				foreach (IDimensionObjectBase currentDimension  in  _dimensions) {
					if (currentDimension.TimeDimension) {
						return currentDimension;
					}
				}
				return null;
			}
		}
		
	
		public virtual IDimensionObjectBase GetDimensionById(String conceptId) {
			return conceptDimensionMap[conceptId];
		}
	
		
		public virtual IList<IDimensionObjectBase> Dimensions {
		  get {
				return new List<IDimensionObjectBase>(_dimensions);
			}
		}
		
	
		public virtual IList<IDimensionObjectBase> GetDimensions(
				params SdmxStructureType[] includeTypes) {
			if (_dimensions != null) {
				IList<IDimensionObjectBase> returnList = new List<IDimensionObjectBase>();
				/* foreach */
				foreach (IDimensionObjectBase dim  in  _dimensions) {
					if (includeTypes != null && includeTypes.Length > 0) {
						/* foreach */
						foreach (SdmxStructureType currentType  in  includeTypes) {
							if (currentType == dim.BuiltFrom
									.StructureType) {
								returnList.Add(dim);
							}
						}
					} else {
						returnList.Add(dim);
					}
				}
				return returnList;
			}
			return new List<IDimensionObjectBase>();
		}
	
		
		public virtual IList<IAttributeObjectBase> Attributes {
		  get {
				return new List<IAttributeObjectBase>(_attributes);
			}
		}
		
	
		
		public virtual IPrimaryMeasureObjectBase PrimaryMeasure {
		  get {
				return _primaryMeasure;
			}
		}
		
	
		
		public virtual IList<IAttributeObjectBase> DatasetAttributes {
		  get {
				return GetAttribute(Org.Sdmxsource.Sdmx.Api.Constants.AttributeAttachmentLevel.DataSet);
			}
		}
		
	
		
		public virtual ISet<IAttributeObjectBase> GroupAttributes {
		  get {
				IList<IAttributeObjectBase> allGroupAttributes = GetAttribute(Org.Sdmxsource.Sdmx.Api.Constants.AttributeAttachmentLevel.Group);
				return new HashSet<IAttributeObjectBase>(allGroupAttributes);
			}
		}
		
	
		public virtual IList<IAttributeObjectBase> GetGroupAttributes(String groupId) {
			IList<IAttributeObjectBase> allGroupAttributes = GetAttribute(Org.Sdmxsource.Sdmx.Api.Constants.AttributeAttachmentLevel.Group);
			IList<IAttributeObjectBase> returnList = new List<IAttributeObjectBase>();
	
			/* foreach */
			foreach (IAttributeObjectBase currentAttribtue  in  allGroupAttributes) {
				if (currentAttribtue.AttachmentGroup.Equals(groupId)) {
					returnList.Add(currentAttribtue);
				}
			}
			return returnList;
		}
	
		
		public virtual IList<IGroupObjectBase> Groups {
		  get {
				return new List<IGroupObjectBase>(_groups);
			}
		}
		
	
		public virtual IGroupObjectBase GetGroup(String id) {
			if (_groups != null) {
				/* foreach */
				foreach (IGroupObjectBase Icurrent  in  _groups) {
					if (Icurrent.Id.Equals(id)) {
						return Icurrent;
					}
				}
			}
			return null;
		}
	
		
		public virtual IList<IAttributeObjectBase> ObservationAttributes {
		  get {
				return GetAttribute(Org.Sdmxsource.Sdmx.Api.Constants.AttributeAttachmentLevel.Observation);
			}
		}
		
	
		
		public virtual IList<IAttributeObjectBase> SeriesAttributes {
		  get {
				return GetAttribute(Org.Sdmxsource.Sdmx.Api.Constants.AttributeAttachmentLevel.DimensionGroup);
			}
		}
		
	
		private IList<IAttributeObjectBase> GetAttribute(
				AttributeAttachmentLevel type) {
			IList<IAttributeObjectBase> returnList = new List<IAttributeObjectBase>();
			/* foreach */
			foreach (IAttributeObjectBase currentAttribtue  in  _attributes) {
				if (currentAttribtue.AttachmentLevel.Equals(type)) {
					returnList.Add(currentAttribtue);
				}
			}
			return returnList;
		}
	
		public virtual String GetAttributeAttachmentGroup(String id) {
			/* foreach */
			foreach (IAttributeObjectBase a  in  _attributes) {
				if (a.Id.Equals(id)) {
					return a.AttachmentGroup;
				}
			}
			return null;
		}
	
		//	
		//	public LinkedHashMap<String, String> orderKey(HashMap<String, String> key) {
		//		LinkedHashMap<String, String> orderedKey = new LinkedHashMap<String, String>();
		//		for (IDimensionObjectBase d : dimensions){
		//			if (key.containsKey(d.getConcept().getId())){
		//				orderedKey.put(d.getConcept().getId(), key.get(d.getConcept().getId()));
		//			}
		//		}
		//		return orderedKey;
		//	}
	
		public virtual String GetGroupId(ISet<String> dimensions0) {
			/* foreach */
			foreach (IGroupObjectBase g  in  _groups) {
				ISet<String> grpDims = new HashSet<String>();
				/* foreach */
				foreach (IDimensionObjectBase d  in  g.Dimension) {
					grpDims.Add(d.Id);
				}
				if (grpDims.Equals(dimensions0)) {
					return g.Id;
				}
			}
			return null;
		}
	}
}
